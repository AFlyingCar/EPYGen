# -*- coding: utf-8 -*-

import sys, datetime, os

import Type, Parse, Section

__version__ = "EpyGen v1.0"

CPP_PY_EXCEPTION_MAPPING = {
    "std::exception": "PyExc_Exception",

    "std::bad_alloc": "PyExc_MemoryError",
    "std::bad_cast": "PyExc_TypeError",
    # "std::bad_exception": "",
    "std::bad_function_call": "PyExc_EnvironmentError", # TODO: Maybe?
    "std::bad_typeid": "PyExc_ValueError",
    "std::bad_weak_ptr": "PyExc_MemoryError",

    "std::logic_error": "PyExc_RuntimeError", # TODO: We should figure out a better error to use
    "std::domain_error": "PyExc_ValueError", # There is no specific domain error
    # "std::future_error": "",
    "std::invalid_argument": "PyExc_ValueError",
    "std::length_error": "PyExc_ValueError",
    "std::out_of_range": "PyExc_IndexError",

    "std::runtime_error": "PyExc_RuntimeError",
    "std::overflow_error": "PyExc_OverflowError",
    "std::range_error": "PyExc_ValueError", # There is no specific range error
    "std::regex_error": "PyExc_ValueError",
    "std::system_error": "PyExc_SystemError",
    "std::underflow_error": "PyExc_UnderflowError"
}

# Use PyDLL instead of CDLL:
#  https://bytes.com/topic/python/answers/701504-fatal-python-error-using-ctypes-python-exceptions
PYTHON_HEADER = """# -*- coding: utf-8 -*-

'''
This file was automatically generated by {0} on {1}.
Do not modify this file unless you know what you are doing.
'''

import ctypes, sys, types

__LIBRARY_{2}__ = ctypes.PyDLL(\"{3}\")
""" # TODO: Include copyright info section

CPP_HEADER = """/*
 * This file was automatically generated by {0} on {1}.
 *  Do not modify this file unless you know what you are doing.
 *
 */
#include <Python.h>
#include <stdexcept>
#include <exception>
""" # TODO: Include copyright info section

PY_DEL_FUNC = """
    def __del__(self):
        if self.cobj and {1}_Destroy:
            {1}_Destroy(self.cobj)
"""

PY_FUNC_LOADER = """{0}try:
{0}    {1} = getattr(__LIBRARY_{2}__, "{1}"){3}
{0}    {1}.argtypes = [{4}]
{0}except AttributeError as e:
{0}    print(str(e), file=sys.stderr)
{0}    {1} = None
"""

CPP_DEL_FUNC = """    {0} void {1}_Destroy(void* ptr) {{
        delete ({2}*)ptr;
    }}
"""

CPP_PY_OBJ_WRAPPER_CREATOR = """{0}if({1} == nullptr) {{
{0}    {1} = PyErr_NewException("{2}.{3}", nullptr, nullptr);
{0}    Py_INCREF({1});
{0}    PyModule_AddObject(PyImport_AddModule("__main__"), "{2}", {1});
{0}}}
"""

PY_TYPE_CHECK = """{0}if type({1}) != {2}:
{0}    {1} = {3}
"""

today = datetime.date.today().isoformat()
lib_obj_name = ""

is_windows = os.name == 'nt'

def CPPTypeToCType(cpptype):
    return cpptype

def createPyTypeCheck(param_name, type, ident = ""):
    return PY_TYPE_CHECK.format(ident, param_name, type.py_type, type.createPyTransformation(param_name))

def createPyFunction(cname, name, function, epy, is_class = False, starting_ident = 0):
    print("Creating function " + function.name)
    func_str = ""

    ident = ('    ' * starting_ident)

    params = ['param' + str(i) for i in range(len(function.param_list))]
    if is_class:
        if function.static:
            func_str += ident + "@classmethod\n"
            params = ["cls"] + params
        else:
            params = ["self"] + params

    func_str += (ident + "def {0}(" + ', '.join(params) + '):\n').format(function.name)

    starting_ident += 1
    ident += '    ' # Now that we are out of the function header, increase the indentation by one

    # func_str += ident + "global {0}\n".format(cname)
    func_str += ident + "if "

    if is_class:
        if not function.static:
            func_str += "self.cobj and "

    func_str += cname

    func_str += ":\n"
    ident += "    "
    starting_ident += 1

    # TODO: Add support for default parameters
    i = 0
    for p in function.param_list:
        func_str += createPyTypeCheck('param' + str(i), p[0], ident)
        i += 1

    func_str += ident + "result = {0}(".format(cname)

    if is_class:
        params = params[1:] # Remove cls/self as we no longer need it and don't want
                            #  to pass it to the function
        if not function.static:
            params = ["ctypes.c_void_p(self.cobj)"] + params

    for i in range(len(params) - 1):
        params[i + 1] = "{0}({1})".format(function.param_list[i][0].py_c_type, 'param' + str(i))

    param_str = ", ".join(params)

    func_str += param_str + ')\n'

    if function.rtype.raw != "void":
        func_str += ident + "return result\n"

    return func_str

def createPyFuncLoader(fname, rtype, params, lib_name, ident = ""):
    print(fname,'->',rtype)
    return PY_FUNC_LOADER.format(ident, fname, lib_name,
                                 "\n{2}    {0}.restype = {1}".format(fname, rtype, ident) if rtype else "",
                                 ','.join([p[0] if type(p[0]) == str else p[0].py_c_type for p in params]))

def createPyCtor(ctor_list, klass, epy):
    # Do not generate a constructor if none are defined
    if len(ctor_list) == 0:
        return ""

    params = ["self"]
    ctor = "    def __init__("

    # Generate parameter listing

    min_params = min([len(i[0]) for i in ctor_list])
    max_params = max([len(i[0]) for i in ctor_list])

    for i in range(min_params):
        params.append("param" + str(i))

    for i in range(max_params - min_params):
        params.append("param" + str(i) + " = None")

    ctor += ", ".join(params) + "):\n"

    ident = "    " * 2

    # Generate Create calls.
    ctor_name = "_pywrapped_{0}_Create".format(klass.name)

    ctor += ident + "if " + ctor_name + ":\n"
    ident += "    "

    # TODO: Add support for default parameters
    i = 0
    for p in ctor_list[0][0]:
        ctor += createPyTypeCheck('param' + str(i), p[0], ident)
        i += 1

    ctor += ident + "self.cobj = {0}(".format(ctor_name)

    # Skip the self parameter
    i = 0
    for p in params[1:]:
        ctor += "{0}({1}), ".format(ctor_list[0][0][i][0].py_c_type, p.split(' ')[0])
        # ctor += p.split(' ')[0] + ', '
        i += 1
    ctor = ctor.rstrip()
    if ctor.endswith(','):
        ctor = ctor[:-1]
    ctor += ")\n"

    ident = "    " * 2
    ctor += ident + "else:\n"
    ctor += ident + "    self.cobj = None"

    return ctor

def createPyClass(klass, epy):
    class_string = ""

    ctor_count = 0
    for c in klass.ctors:
        ctor_name = "_pywrapped_{0}_Create{1}".format(klass.name, str(ctor_count) if ctor_count > 0 else "")
        class_string += createPyFuncLoader(ctor_name, "ctypes.c_void_p", c[0], epy.lib_name_fmt)
        ctor_count += 1

    class_string += createPyFuncLoader("{0}_Destroy".format(klass.name_fmt), "", [("ctypes.c_void_p",)], epy.lib_name_fmt)

    class_string += "class {0}(object):\n".format(klass.name)

    class_string += createPyCtor(klass.ctors, klass, epy)

    if klass.dtor:
        class_string += PY_DEL_FUNC.format(epy.lib_name_fmt, klass.name_fmt)

    # name -> countx
    functions_found = {f.name: 0 for f in klass.functions}

    for f in klass.functions:
        full_name = klass.name_fmt + '_' + f.name + str(functions_found[f.name])
        class_string += createPyFunction(full_name, f.name + str(functions_found[f.name]),
                                         f, epy, True, 1)
        functions_found[f.name] += 1

    return class_string

def generatePython(epy):
    python = PYTHON_HEADER.format(__version__, today, epy.lib_name_fmt, epy.lib)

    for section in epy.sections:
        is_class = type(section) is Section.Class
        # Namespaces and classes both use the same code for their header
        if issubclass(type(section), Section.Namespace):
            functions_found = {f.name: 0 for f in section.functions}
            for f in section.functions:
                full_name = section.name_fmt + '_' + f.name + str(functions_found[f.name])
                python += createPyFuncLoader(full_name, f.rtype.py_c_type, ([("ctypes.c_void_p",)] if is_class and not f.static else []) + f.param_list, epy.lib_name_fmt)

        if type(section) is Section.Class:
            python += createPyClass(section, epy)
        elif type(section) is Parse.PyLiteral:
            python += section.literal

    return python

def createCPPNullCheck(ident, var, fname):
    return ("    " * ident + "if({0} == nullptr) {{\n" +\
            "    " * ident + "    PyErr_SetString(PyExc_ValueError, \"Null pointer given for parameter {0} in function {1}\");\n" +\
            "    " * ident + "    return nullptr;\n" +\
            "    " * ident + "}}\n").format(var, fname)

def createCPPPyExceptionObjectName(t):
    if t in CPP_PY_EXCEPTION_MAPPING:
        return CPP_PY_EXCEPTION_MAPPING[t]
    else:
        return "_pywrapped_EXCEPTION_" + '_'.join(t.split('::'))

def createCPPPyExceptionWrapper(throw, fname):
    exc_wrapper = "    " * 2
    exc_obj_name = createCPPPyExceptionObjectName(throw)

    nspaces = throw.split('::')[:-1]
    exc_name = throw.split('::')[-1]

    # Just to be safe
    if not nspaces:
        nspaces = ["_"] # TODO: This should be something else

    # Convert things like std::except into std.except
    py_nspaces = '.'.join(nspaces)

    exc_wrapper += "}} catch(const {0}& e) {{\n".format(throw)
    if throw not in CPP_PY_EXCEPTION_MAPPING:
        exc_wrapper += CPP_PY_OBJ_WRAPPER_CREATOR.format("    " * 3, exc_obj_name, py_nspaces, exc_name)

    exc_wrapper += "    " * 3 + "PyErr_SetString({0}, e.what());\n".format(exc_obj_name)
    exc_wrapper += "    " * 3 + "return 0;\n"

    return exc_wrapper

def createCPPCtor(klass_name, params, throws, epy, referenced_throws = [], ctor_num = 0, is_virtual = False):
    ctor_str = "    "

    func_name = "{0}'s Constructor".format(klass_name)

    # Generate exception globals if they have not yet been referenced
    for t in throws:
        if t not in referenced_throws and t not in CPP_PY_EXCEPTION_MAPPING:
            ctor_str += "static PyObject* " + createCPPPyExceptionObjectName(t) + " = nulllptr;\n    "

            referenced_throws.append(t)

    if is_windows:
        ctor_str += "__declspec(dllexport) "

    ctor_str += "void* _pywrapped_{0}_Create{1}(".format(klass_name, str(ctor_num) if ctor_num > 0 else "")

    if is_virtual:
        klass_name = "_pywrapped_{0}".format(klass_name)

    pcount = 0
    for p in params:
        ctor_str += p[0].c_type + ' param' + str(pcount) + ','
        pcount += 1

    if is_virtual:
        ctor_str += "PyObject* pyobj"

    if ctor_str.endswith(','):
        ctor_str = ctor_str[:-1]

    ctor_str += ") {\n"

    ctor_str += "    " * 2 + "try {\n"
    ctor_str += "    " * 3 + "return new {0}(".format(klass_name)

    pcount = 0
    for p in params:
        # Generate casts to cpp types
        ctor_str += "{0}({1})".format(p[0].raw, 'param' + str(pcount)) + ","

    if is_virtual:
        ctor_str += "pyobj"

    if ctor_str.endswith(','):
        ctor_str = ctor_str[:-1] # Remove the trailing ,
    ctor_str += ");\n"

    for t in throws:
        ctor_str += createCPPPyExceptionWrapper(t, func_name)

    ctor_str += "    " * 2 + "} catch (...) {\n"
    ctor_str += "    " * 3 + "PyErr_SetString(PyExc_RuntimeError, \"An unspecified exception has occurred in {0}\");\n".format(func_name)
    ctor_str += "    " * 3 + "return nullptr;\n"
    ctor_str += "    " * 2 + "}\n"

    return ctor_str + "    }\n"

def createCPPFunctionHeader(cres_type, full_name, function, is_class, is_virtual = False):
    func_header = ""

    # Don't generate the declspec call on virtual functions (those defined in a class wrapper)
    if is_windows and not is_virtual:
        func_header += "__declspec(dllexport) "

    if type(cres_type) == str:
        func_header += cres_type + " "
    else:
        if cres_type.is_array:
            func_header += "void "
        else:
            func_header += cres_type.c_type + ' '
    func_header += full_name + "("

    # Generate parameter listing

    if is_class and not function.static:
        if function.const:
            func_header += "const "
        func_header += "void* self,"

    pcount = 0
    for p in function.param_list:
        func_header += p[0].c_type + ' param' + str(pcount) + ','
        pcount += 1

    if type(cres_type) != str:
        if cres_type.is_array:
            func_header += cres_type.toCArrayOutputParams().format("result")

    if func_header.endswith(','):
        func_header = func_header[:-1] # Remove the trailing ,

    func_header += ")"
    return func_header

def createCPPFunction(full_name, name, function, epy, referenced_throws = [], is_class = False):
    func_string = "    "
    cres_type = CPPTypeToCType(function.rtype)

    # Generate exception globals if they have not yet been referenced
    for t in function.throws:
        if t not in referenced_throws and t not in CPP_PY_EXCEPTION_MAPPING:
            func_string += "static PyObject* " + createCPPPyExceptionObjectName(t) + " = nulllptr;\n    "

            referenced_throws.append(t)

    # Generate header
    func_string += createCPPFunctionHeader(cres_type, full_name, function, is_class) + " {\n"

    has_ret_val = (cres_type.raw != "void")
    # Generate contents
    if is_class and not function.static:
        func_string += createCPPNullCheck(2, "self", name)

    func_string += "    " * 2 + "try {\n"
    func_string += "    " * 3

    if has_ret_val:
        func_string += "return "

    call = ""

    if is_class:
        if function.static:
            call += "{0}::".format(function.owner.name)
        else:
            call += "(({0}*)self)->".format(("const " if function.const else "") + function.owner.name)
    call += "{0}(".format(name)

    pcount = 0
    for p in function.param_list:
        # Generate casts to cpp types
        call += "{0}({1})".format(p[0].raw, p[0].createCTransformation('param' + str(pcount))) + ","

    if call.endswith(','):
        call = call[:-1] # Remove the trailing ,
    call += ")"

    if has_ret_val:
        call = cres_type.createCTransformation(call)

    func_string += call + ";\n"

    for t in function.throws:
        func_string += createCPPPyExceptionWrapper(t, name)

    func_string += "    " * 2 + "} catch (...) {\n"
    func_string += "    " * 3 + "PyErr_SetString(PyExc_RuntimeError, \"An unspecified exception has occurred in {0}\");\n".format(name)
    func_string += "    " * 3 + "return nullptr;\n"
    func_string += "    " * 2 + "}\n"

    func_string += "    }\n"

    return func_string

def createCPPVirtualFuncWrapper(func, orig_name, wrap_name):
    vfunc_str = ""
    ident = "    " * 2

    # Make sure we don't return references, as we do not hold onto the lifespan
    #  here
    # Note: This is a temporary fix, but I just don't really know how to properly
    #  handle references yet. Fix ASAP as virtual functions that return references
    #  cannot be exposed.
    rtype = func.rtype.cpp_type if func.rtype.is_reference else func.rtype.raw

    # We pass False for is_class so that no `self` parameter gets generated
    vfunc_str += ident + createCPPFunctionHeader(rtype, func.name, func, False, True)
    vfunc_str += (" const" if func.const else "") + " override {\n"

    ident += "    "

    param_str = ", ".join(['param' + str(i) for i in range(len(func.param_list))])

    vfunc_str += ident + "if(m_pyobj != nullptr){\n"
    vfunc_str += ident + "    PyObject* result = PyObject_CallMethodObjArgs(m_pyobj, PyBytes_FromString(\"{0}\"), {1}".format(func.name, param_str)
    vfunc_str += "NULL);\n"
    # Return PyObject as CPP type here
    if func.rtype != "void":
        vfunc_str += ident + "    " + func.rtype.createPyObjectTransformation("result", "return ") + ";\n"
        # vfunc_str += ident + "    return Epy::PyObjectToType<{0}>(result);\n".format(func.rtype.raw)

    vfunc_str += ident + "} else {\n"
    vfunc_str += ident + "    {3}{0}::{1}({2});\n".format(orig_name, func.name, param_str, "return " if func.rtype != "void" else "")
    vfunc_str += ident + "}\n"

    ident = "    " * 2
    vfunc_str += ident + "}\n"

    return vfunc_str

def createCPPClassWrapperCtor(orig_name, wrap_name, ctor):
    ctor_str = "        {0}(".format(wrap_name)
    # Generate Constructor Params
    pcount = 0
    for p in ctor[0]:
        ctor_str += p[0].raw + ' param' + str(pcount) + ','
        pcount += 1

    ctor_str += "PyObject* pyobj): "

    line_up = len(ctor_str)

    ctor_str += "{0}({1}),\n".format(orig_name, ', '.join(['param' + str(i) for i in range(pcount)]))
    # Pass parameters to original constructor

    ctor_str += (" " * line_up) + "m_pyobj(pyobj)\n"
    ctor_str += "        { }\n"

    return ctor_str

def createCPPClassWrapper(orig_name, wrap_name, klass):
    class_string = ""

    # Use structure so we don't havve to deal with accessors
    class_string += "class {0}: public {1} {{\n".format(wrap_name, orig_name)
    class_string += "    public:\n"
    for c in klass.ctors:
        class_string += createCPPClassWrapperCtor(orig_name, wrap_name, c)
    class_string += "        ~{0}() {{ }}\n".format(wrap_name)

    for f in klass.virtual_funcs:
        # Generate a function wrapper for every virtual function which handles
        #  whether to use the Python function or the C++ one
        class_string += createCPPVirtualFuncWrapper(f, orig_name, wrap_name)

    class_string += "    private:\n"
    class_string += "       PyObject* m_pyobj;\n"

    class_string += "};\n"

    return class_string

def createCPPClass(klass, epy, reffed_throws):
    class_string = ""

    class_name = klass.name

    is_virtual = len(klass.virtual_funcs) > 0

    if is_virtual:
        wrapped_name = "_pywrapped_" + class_name
        class_string += createCPPClassWrapper(class_name, wrapped_name, klass)
        # class_name = wrapped_name

    class_string += "extern \"C\" {\n"

    ccount = 0
    for ctor in klass.ctors:
        class_string += createCPPCtor(class_name, ctor[0], ctor[2], epy, reffed_throws, ccount, is_virtual)
        ccount += 1

    if klass.dtor:
        class_string += CPP_DEL_FUNC.format("__declspec(dllexport)" if is_windows else "", klass.name_fmt, klass.name)

    functions_found = {f.name: 0 for f in klass.functions}
    for f in klass.functions:
        full_name = klass.name_fmt + '_' + f.name + str(functions_found[f.name])
        class_string += createCPPFunction(full_name, f.name, f, epy, reffed_throws, True)

    class_string += "}\n"

    return class_string

def generateCPP(epy):
    cplusplus = CPP_HEADER.format(__version__, today)

    reffed_throws = []

    for section in epy.sections:
        if type(section) is Section.Class:
            cplusplus += createCPPClass(section, epy, reffed_throws)
        elif type(section) is Parse.CppLiteral:
            cplusplus += section.literal

    return cplusplus

def generate(filename):
    epy = Parse.Epy(filename, open(filename).read().strip(), lib_obj_name.replace('\\', '\\\\'))

    print("EPY\n===")
    print("has class:", epy.hasclasses)
    print("has enum:", epy.hasenums)

    for s in epy.sections:
        print(s)

    python = generatePython(epy)

    # print("PYTHON\n======\n")
    # print(python)

    cpp = generateCPP(epy)

    print("CPP\n===\n")
    print(cpp)

    py_name = filename[:-3] + "py"
    cpp_name = filename[:-4] + "_wrap.cpp"

    print("Writing to " + py_name)
    open(py_name, 'w').write(python)

    print("Writing to " + cpp_name)
    open(cpp_name, 'w').write(cpp)

def main():
    if(len(sys.argv) < 3):
        print("Invalid number of arguments.")
        return

    global lib_obj_name
    lib_obj_name = sys.argv[1]
    files = sys.argv[2:];

    for f in files:
        generate(f)

if __name__ == "__main__":
    main()
