# -*- coding: utf-8 -*-

import sys, re, datetime

__version__ = "EpyGen v1.0"

CLASS_TYPE = 0
NSPACE_TYPE = 1
ENUM_TYPE = 2

PYTHON_HEADER ="""
# -*- coding: utf-8 -*-

'''
This file was automatically generated by {0} on {1}.
Do not modify this file unless you know what you are doing.
'''

import ctypes\n__LIBRARY_{2}__ = ctypes.CDLL(\"{3}\")
""" # TODO: Include DP copyright

today = datetime.date.today().isoformat()
lib_obj_name = ""

class Function(object):
    def __init__(self, func, rtype, param_list, tparam_list, const, static, virtual, owner):
        self.name = func
        self.rtype = rtype
        self.param_list = param_list
        self.tparam_list = tparam_list
        self.const = const
        self.static = static
        self.virtual = virtual
        self.owner = owner

class Operator(Function):
    def __init__(self, func, rtype, param_list, tparam_list, const, static, virtual, owner):
        super().__init__(func, rtype, param_list, tparam_list, const, static, virtual, owner)

class PyLiteral(object):
    def __init__(self, literal):
        self.literal = literal

class CppLiteral(object):
    def __init__(self, literal):
        self.literal = literal

class Section(object):
    def __init__(self, name):
        self.name = name
        self.name_fmt = formatName(name)

    def __str__(self):
        return self.name

class Namespace(Section):
    def __init__(self, name):
        super().__init__(name)
        self.functions = []

    def __str__(self):
        s = super().__str__() + "\n"
        for f in self.functions:
            s += str(f) + "\n"

        return s

class Class(Namespace):
    def __init__(self, name, tparams):
        super().__init__(name)
        self.tparams = tparams

        # Tuple: (param_list, tparam_list, Class)
        self.ctors = []

        # Nothing special needs to be done with the destructor, we just need to know that we have one
        self.dtor = False

    def __str__(self):
        s = super().__str__()
        for c in self.ctors:
            s += str(c) + "\n"
        return s

class Enum(Section):
    def __init__(self, name, eclass):
        super().__init__(name)

        self.eclass = eclass

        self.values = []

    def __str__(self):
        s = super().__str__() + "\n"
        for v in self.values:
            s += v[0] + "=" + v[1] + "\n"
        return s

class Epy(object):
    def __init__(self, filename, contents, lib_name):
        self.mod_name = ""
        self.sections = []
        self.lib = lib_name
        self.lib_name_fmt = formatLibName(lib_name)
        self.hasclasses = False
        self.hasenums = False

        self.parse(contents)

    def parse(self, contents):
        statement = ""
        state = {
            "in_literalpy": False,
            "in_literalcpp": False,
            "in_section": False,
            "sname": "",
            "sobj": None,
            "prev_c": ""
        }
        i = 0

        while i < len(contents):
            c = contents[i]

            if c == ";" and not (state["in_literalpy"] or state["in_literalcpp"]):
                state = self.parseStatement(statement.strip(), state)
                statement = ""
            elif c == "@":
                i += 1
                ppstatement = ""

                # Ignore non-linebreaking whitespace
                while contents[i] in " \t":
                    i += 1
                while contents[i] not in " \n\r\t":
                    ppstatement += contents[i]
                    i += 1

                if not ppstatement:
                    if state["in_literalpy"]:
                        state["in_literalpy"] = False
                        self.sections.append(PyLiteral(statement))

                        statement = ""
                    elif state["in_literalcpp"]:
                        state["in_literalcpp"] = False
                        self.sections.append(CppLiteral(statement))

                        statement = ""
                    else:
                        print("Error: Encountered closing @ when outside of literal block.")
                elif ppstatement == "py":
                    state["in_literalpy"] = True
                elif ppstatement == "cpp":
                    state["in_literalcpp"] = True
                elif ppstatement == "include":
                    # TODO
                    pass
                else:
                    print("Unrecognized ppstatement " + ppstatement)
                    return
            else:
                if c == "/" and not (state["in_literalpy"] or state["in_literalcpp"]):
                    i += 1
                    if contents[i] == "/":
                        while contents[i] != "\n":
                            i += 1
                        continue
                    elif contents[i] == "*":
                        j = i - 1
                        n = j

                        while not (contents[j] == "*" and contents[i] == "/"):
                            i += 1
                            j += 1

                        i += 1 # Increment one more time to get past that pesky closing /
                        continue

                statement += c
                state["prev_c"] = c
            i += 1

    def parseStatement(self, statement, state):
        print("Statement:", statement)

        if not state["in_section"] and not self.mod_name:
            self.mod_name = statement
        elif statement == "start":
            state["in_section"] = True
        elif statement == "end":
            state["in_section"] = False
            if state["sobj"]:
                self.sections.append(state["sobj"])
            else:
                print("Internal Error: sobj is None")
                state["error"] = True
                return state
        elif statement.startswith("class"):
            state = self.parseClassStatement(statement, state)
            self.hasclasses = True
        elif statement.startswith("namespace"):
            state = self.parseNamespaceStatement(statement, state)
        elif statement.startswith("enum"):
            state = self.parseEnumStatement(statement, state)
            self.hasenums = True
        elif statement.startswith("ctor"):
            if not state["sobj"]:
                print("Internal Error: sobj is None")
                state["error"] = True
                return state
            state = self.parseCtorStatement(statement, state)
        elif statement.startswith("dtor"):
            if not state["sobj"]:
                print("Internal Error: sobj is None")
                state["error"] = True
                return state
            state = self.parseDtorStatement(statement, state)
        elif statement.startswith("func"):
            if not state["sobj"]:
                print("Internal Error: sobj is None")
                state["error"] = True
                return state
            state = self.parseFunc(statement, state)
        elif statement.startswith("operator"):
            if not state["sobj"]:
                print("Internal Error: sobj is None")
                state["error"] = True
                return state
            state = self.parseOperator(statement, state)
        elif state["stype"] == ENUM_TYPE:
            value = self.parseEnumValue(statement, state)

            if not state["sobj"]:
                print("Internal Error: sobj is None")
                state["error"] = True
                return state

            if not type(state["sobj"]) is Enum:
                print("Internal Error: sobj is not Enum")
                state["error"] = True
                return state

            state["sobj"].values.append(value)

        return state

    def parseTParams(self, param_str):
        param_str = param_str.strip() # Just to be safe
        if not (param_str.startswith('<') and param_str.endswith('>')):
            print("Error: Template parameter lists must be surrounded with <>")
            return None

        print("parsing tparam list")

        param_str = param_str[1:-1]

        params = []

        pcount = 0
        ptype = ""
        defaulted = False
        i = 0
        while i < len(param_str):
            c = param_str[i]

            if c == ',' and pcount == 0:
                print("Found parameter `" + ptype + "`")
                params.append((ptype.strip(), defaulted))
                ptype = ""
                defaulted = False
                i += 1 # skip over the comma
                continue
            elif c == '=':
                defaulted = True
                i += 1
                continue

            # Handle template parameters and function pointers
            elif c == '<':
                pcount += 1
            elif c == '(':
                pcount += 1
            elif c == '>':
                pcount -= 1
            elif c == ')':
                pcount -= 1

            ptype += c

            i += 1

        if ptype:
            print("Found parameter `" + ptype + "`")
            params.append((ptype.strip(), defaulted))

        print("Found " + str(len(params)) + " template parameters")

        print("done")

        return params

    def parseParamList(self, param_str):
        param_str = param_str.strip() # Just to be safe
        if not (param_str.startswith('(') and param_str.endswith(')')):
            print("Error: Parameter lists must be surrounded with ()")
            return None

        print("parsing param list")

        param_str = param_str[1:-1]

        params = []

        pcount = 0
        ptype = ""
        defaulted = False
        i = 0
        while i < len(param_str):
            c = param_str[i]

            if c == ',' and pcount == 0:
                print("Found parameter `" + ptype + "`")
                params.append((ptype.strip(), defaulted))
                ptype = ""
                defaulted = False
                i += 1 # skip over the comma
                continue
            elif c == '=':
                defaulted = True
                i += 1
                continue

            # Handle template parameters and function pointers
            elif c == '<':
                pcount += 1
            elif c == '(':
                pcount += 1
            elif c == '>':
                pcount -= 1
            elif c == ')':
                pcount -= 1

            ptype += c

            i += 1

        if ptype:
            print("Found parameter `" + ptype + "`")
            params.append((ptype.strip(), defaulted))

        print("Found " + str(len(params)) + " parameters")

        print("done")

        return params

    def parseCtorStatement(self, statement, state):
        if not type(state["sobj"]) is Class:
            print("Internal Error: sobj is `" + str(type(state["sobj"])) + "` not Class")
            state["error"] = True
            return state

        rest = statement[4:].lstrip()
        tparam_str, param_str = rest.split('(')
        tparam_str.rstrip()
        param_str = '(' + param_str.lstrip()
        if '<' in tparam_str:
            tparam_list = self.parseTParams(tparam_str)
        else:
            tparam_list = []

        param_list = self.parseParamList(param_str)

        if param_list is None:
            state["error"] = True
        else:
            state["sobj"].ctors.append((param_list, tparam_list, state["sobj"]))

        return state

    def parseDtorStatement(self, statement, state):
        if not type(state["sobj"]) is Class:
            print("Internal Error: sobj is not Class")
            state["error"] = True
            return state

        state["sobj"].dtor = True

        return state

    def parseFunc(self, statement, state):
        isclass = False

        if type(state["sobj"]) is Class:
            isclass = True
        elif type(state["sobj"]) is Namespace:
            isclass = False
        else:
            print("Internal Error: sobj is `" + str(type(state["sobj"])) + "` not Class")
            state["error"] = True
            return state

        func = statement[4:].lstrip()

        func, rtype = func.rsplit("->", 1)

        func = func.rstrip()
        rtype = rtype.lstrip()

        const = False
        static = False
        virtual = False

        # class specific parsing
        # We check the space after each one to make sure the keywords aren't part of the next token
        if func.startswith("const "):
            if not isclass:
                print("Error: const only allowed on class sections.")
                state["error"] = True
                return state
            const = True
            func = func[5:].lstrip()
        if func.startswith("static "):
            if not isclass:
                print("Error: static only allowed on class sections.")
                state["error"] = True
                return state
            static = True
            func = func[6:].lstrip()
        elif func.startswith("virtual "):
            if not isclass:
                print("Error: virtual only allowed on class sections.")
                state["error"] = True
                return state
            virtual = True
            func = func[6:].lstrip()

        func_and_tparams, param_str = func.split('(', 1)
        if('<') in func_and_tparams:
            func, tparams = func_and_tparams.split('<')
            tparams = '<' + tparams
        else:
            func = func_and_tparams
            tparams = "<>"
        param_str = '(' + param_str.lstrip()

        print("Parsing function `" + func + "` with rtype `" + rtype + "`, parameters",
              param_str, "tparams", tparams, "and modifiers",
              ("const " if const else ""), ("static " if static else ""),
              ("virtual" if virtual else ""))

        param_list = self.parseParamList(param_str)
        tparam_list = self.parseTParams(tparams)

        # Verify that there are no spaces in the function name
        if re.match('^[\w]+$', func) is None:
            print("Invalid function name `" + func + '`')
            state["error"] = True
            return state

        # Generate Function object and append to sobj
        state["sobj"].functions.append(Function(func, rtype, param_list,
                                                tparam_list, const, static,
                                                virtual, state["sobj"]))

        return state

    def parseOperator(self, statement, state):
        isclass = False

        if type(state["sobj"]) is Class:
            isclass = True
        else:
            print("Internal Error: sobj is `" + str(type(state["sobj"])) + "` not Class")
            state["error"] = True
            return state

        func = statement[8:].lstrip()

        func, rtype = func.rsplit("->", 1)

        func = func.rstrip()
        rtype = rtype.lstrip()

        const = False
        static = False
        virtual = False

        # class specific parsing
        # We check the space after each one to make sure the keywords aren't part of the next token
        if func.startswith("const "):
            if not isclass:
                print("Error: const only allowed on class sections.")
                state["error"] = True
                return state
            const = True
            func = func[5:].lstrip()
        if func.startswith("static "):
            if not isclass:
                print("Error: static only allowed on class sections.")
                state["error"] = True
                return state
            static = True
            func = func[6:].lstrip()
        elif func.startswith("virtual "):
            if not isclass:
                print("Error: virtual only allowed on class sections.")
                state["error"] = True
                return state
            virtual = True
            func = func[6:].lstrip()

        func_and_tparams, param_str = func.split('(', 1)
        if('<') in func_and_tparams:
            func, tparams = func_and_tparams.split('<')
            tparams = '<' + tparams
        else:
            func = func_and_tparams
            tparams = "<>"
        param_str = '(' + param_str.lstrip()

        print("Parsing function `" + func + "` with rtype `" + rtype + "`, parameters",
              param_str, "tparams", tparams, "and modifiers",
              ("const " if const else ""), ("static " if static else ""),
              ("virtual" if virtual else ""))

        param_list = self.parseParamList(param_str)
        tparam_list = self.parseTParams(tparams)

        # Generate Function object and append to sobj
        state["sobj"].functions.append(Operator(func, rtype, param_list,
                                                tparam_list, const, static,
                                                virtual, state["sobj"]))

        return state

    def parseClassStatement(self, statement, state):
        # Section Type = class
        state["stype"] = CLASS_TYPE

        # Parse name
        left = statement[5:].lstrip()
        tstart = left.find("<")
        tparams = []
        if tstart >= 0:
            tparams = self.parseTParams(left[tstart:])
            state["sname"] = left[:tstart]
        else:
            state["sname"] = left

        state["sobj"] = Class(state["sname"], tparams)

        return state

    def parseEnumStatement(self, statement, state):
        state["stype"] = ENUM_TYPE

        rest = statement[4:].lstrip()

        eclass = False
        if rest.startswith("class"):
            eclass = True
            rest = rest[5:].lstrip()

        state["sobj"] = Enum(rest, eclass)

        return state

    def parseNamespaceStatement(self, statement, state):
        state["stype"] = NSPACE_TYPE

        name = statement[9:].lstrip()

        state["sobj"] = Namespace(name)

        return type

    def parseEnumValue(self, statement, state):
        if not type(state["sobj"]) is Enum:
            print("Internal Error: Values cannot be specified outside of enumerations.")
            state["error"] = True
            return state

        if '=' in statement:
            name, default = statement.split('=')
            name = name.rstrip()
            default = default.lstrip()
        else:
            name = statement
            default = ""

        return (name, default)

def formatName(name):
    return "__pywrapped_" + ('_'.join(name.split('::')))

def formatLibName(lib_name):
    return '_'.join(lib_name.split('.')).upper() # libfile.so.1 -> LIBFILE_SO_1

def createPyTypeCheck(param_name, type):
    return ""

def createPyFunction(cname, name, function, epy, is_class = False, starting_ident = 0):
    print("Creating function " + name)

    ident = ('    ' * starting_ident)

    params = ['param' + str(i) for i in range(len(function.param_list))]

    func_str = (ident + "def {0}(" + ', '.join(params) + '):\n').format(name)

    ident += '    ' # Now that we are out of the function header, increase the indentation by one

    if is_class:
        func_str += ident + "if self.cobj:\n"
        ident += "    "

    # TODO: Add support for default parameters
    i = 0
    for p in function.param_list:
        func_str += createPyTypeCheck('param' + str(i), p)
        i += 1

    func_str += ident + "result = getattr({0}, \"{1}\")(".format(epy.lib_name_fmt, cname)

    if is_class:
        params = ["self.cobj"] + params

    func_str += ", ".join(params) + ')\n'

    if function.rtype != "void":
        func_str += ident + "return result\n"

    return func_str

def createPyOperator():
    return ""

def createPyCtor(ctor_list):
    return ""

def createPyClass(klass, epy):
    class_string = "class {0}(object):\n    pass\n".format(klass.name)

    class_string += createPyCtor(klass.ctors)

    # name -> countx
    functions_found = {f.name: 0 for f in klass.functions}

    for f in klass.functions:
        full_name = klass.name_fmt + '_' + f.name + str(functions_found[f.name])
        class_string += createPyFunction(full_name, f.name + str(functions_found[f.name]),
                                         f, epy, True, 1)
        functions_found[f.name] += 1

    return class_string

def generatePython(epy):
    python = PYTHON_HEADER.format(__version__, today, epy.lib_name_fmt, epy.lib)

    for section in epy.sections:
        if type(section) is Class:
            python += createPyClass(section, epy)

    return python

def generateCPP(epy):
    pass

def generate(filename):
    epy = Epy(filename, open(filename).read().strip(), lib_obj_name)

    print("EPY\n===")
    print("has class:", epy.hasclasses)
    print("has enum:", epy.hasenums)

    for s in epy.sections:
        print(s)

    python = generatePython(epy)

    print(python)

    cpp = generateCPP(epy)

    py_name = filename[:-3] + "py"
    cpp_name = filename[:-4] + "_wrap.cpp"

    print("Writing to " + py_name)
    # open(py_name, 'w').write(python)

    print("Writing to " + cpp_name)
    # open(cpp_name, 'w').write(cpp)

def main():
    if(len(sys.argv) < 3):
        print("Invalid number of arguments.")
        return

    global lib_obj_name
    lib_obj_name = sys.argv[1]
    files = sys.argv[2:];

    for f in files:
        generate(f)

if __name__ == "__main__":
    main()
