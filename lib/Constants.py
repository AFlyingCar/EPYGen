# -*- coding: utf-8 -*-
# @Author: Tyler Robbins
# @Date:   2018-07-29 20:29:25

import datetime, os

""" The Version string of this program. """
VERSION = "EpyGen v1.0"

""" True if this is running on Windows, False otherwise. """
IS_WINDOWS = os.name == 'nt'

""" Set to True to enable debugging. """
ENABLE_DEBUG = False

PRIMITIVES = {
    "int": "long",
    "float": "double",
    "double": "long",
    "char": "long",
    "short": "long",
    "long": "long"
}

PRIMITIVE_CONVERSION_FUNCTIONS = {
    "int": "PyLong_FromLong",
    "float": "PyFloat_FromDouble",
    "double": "PyFloat_FromDouble",
    "size_t": "PyLong_FromSize_t",
    "char": "PyLong_FromLong",
    "short": "PyLong_FromLong",
}

""" A mapping of C++ standard exceptions to their CPython equivalents. """
CPP_PY_EXCEPTION_MAPPING = {
    "std::exception": "PyExc_Exception",

    "std::bad_alloc": "PyExc_MemoryError",
    "std::bad_cast": "PyExc_TypeError",
    # "std::bad_exception": "",
    "std::bad_function_call": "PyExc_EnvironmentError", # TODO: Maybe?
    "std::bad_typeid": "PyExc_ValueError",
    "std::bad_weak_ptr": "PyExc_MemoryError",

    "std::logic_error": "PyExc_RuntimeError", # TODO: We should figure out a better error to use
    "std::domain_error": "PyExc_ValueError", # There is no specific domain error
    # "std::future_error": "",
    "std::invalid_argument": "PyExc_ValueError",
    "std::length_error": "PyExc_ValueError",
    "std::out_of_range": "PyExc_IndexError",

    "std::runtime_error": "PyExc_RuntimeError",
    "std::overflow_error": "PyExc_OverflowError",
    "std::range_error": "PyExc_ValueError", # There is no specific range error
    "std::regex_error": "PyExc_ValueError",
    "std::system_error": "PyExc_SystemError",
    "std::underflow_error": "PyExc_UnderflowError"
}

# Use PyDLL instead of CDLL:
#  https://bytes.com/topic/python/answers/701504-fatal-python-error-using-ctypes-python-exceptions
""" A header template to be placed at the beginning of all generated Python files. """
PYTHON_HEADER = """# -*- coding: utf-8 -*-

'''
This file was automatically generated by {0} on {1}.
Do not modify this file unless you know what you are doing.
'''

import ctypes, sys, types, os

__LIBRARY_{2}__ = ctypes.PyDLL(os.path.join(os.path.dirname(os.path.realpath(__file__)),{4},\"{3}\"))
""" # TODO: Include copyright info section

""" A header template to be placed at the beginning of all generated C++ files."""
CPP_HEADER = """/*
 * This file was automatically generated by {0} on {1}.
 *  Do not modify this file unless you know what you are doing.
 *
 */
#include <Python.h>
#include <stdexcept>
#include <exception>
""" # TODO: Include copyright info section

""" A template for generating Python destructor calls. """
PY_DEL_FUNC = """
    def __del__(self):
        if self.cobj and {1}_Destroy:
            {1}_Destroy(self.cobj)
"""

""" A template for loading functions from the library in Python. """
PY_FUNC_LOADER = """{0}try:
{0}    {1} = getattr(__LIBRARY_{2}__, "{1}"){3}
{0}    {1}.argtypes = [{4}]
{0}except AttributeError as e:
{0}    print(str(e), file=sys.stderr)
{0}    {1} = None
"""

""" A template for the C++ destructor wrapper in generated C++ files. """
CPP_DEL_FUNC = """    {0} void {1}_Destroy(void* ptr) {{
        delete ({2}*)ptr;
    }}
"""

""" A template for creating Py Exception objects in generated C++ files if they
    have not already been generated.
"""
CPP_PY_OBJ_WRAPPER_CREATOR = """{0}if({1} == nullptr) {{
{0}    {1} = PyErr_NewException("{2}.{3}", nullptr, nullptr);
{0}    Py_INCREF({1});
{0}    PyModule_AddObject(PyImport_AddModule("__main__"), "{2}", {1});
{0}}}
"""

""" A template for generated python files which attempts to verify the type of a
    variable.
"""
PY_TYPE_CHECK = """{0}if type({1}) != {2}:
{0}    {1} = {3}
"""

CPP_VECTOR_TO_PYOBJECT_TRANSFORMATION = """[]({2} vec) -> PyObject* {{
{0}    PyObject* list = PyList_New(vec.size());
{0}    if(!list) {{
{0}        PyErr_SetString(PyExc_MemoryError, "Unable to allocate enough memory for list elements.");
{0}        return Py_None;
{0}    }}
{0}    for(size_t i = 0; i < vec.size(); ++i) {{
{0}        PyObject* obj = {1}(vec[i]);
{0}        if(!obj) {{
{0}            Py_DECREF(list);
{0}            PyErr_SetString(PyExc_MemoryError, "Unable to allocate enough memory for list elements.");
{0}            return Py_None;
{0}        }}
{0}        PyList_SET_ITEM(list, i, obj);
{0}    }}
{0}    return list;
{0}}}"""

CPP_MAP_TO_PYOBJECT_TRANSFORMATION = """[]({3} map) -> PyObject* {{
{0}    PyObject* dict = PyDict_New();
{0}    if(!dict) {{
{0}        PyErr_SetString(PyExc_MemoryError, "Unable to allocate enough memory for dict elements.");
{0}        return Py_None;
{0}    }}
{0}    for(auto& entry : map) {{
{0}        PyObject* key = {1}(entry.first);
{0}        if(!key) {{
{0}            Py_DECREF(dict);
{0}            PyErr_SetString(PyExc_MemoryError, "Unable to allocate enough memory for dict elements.");
{0}            return Py_None;
{0}        }}
{0}        PyObject* val = {2}(entry.second);
{0}        if(!val) {{
{0}            Py_DECREF(key);
{0}            Py_DECREF(dict);
{0}            PyErr_SetString(PyExc_MemoryError, "Unable to allocate enough memory for dict elements.");
{0}            return Py_None;
{0}        }}
{0}        PyDict_SetItem(dict, key, val);
{0}    }}
{0}    return dict;
{0}}}"""

""" The current date in ISO format. """
TODAY = datetime.date.today().isoformat()

