# -*- coding: utf-8 -*-
# @Author: Tyler Robbins
# @Date:   2018-07-29 20:29:25

import datetime, os

""" The Version string of this program. """
VERSION = "EpyGen v1.0"

""" True if this is running on Windows, False otherwise. """
IS_WINDOWS = os.name == 'nt'

""" Set to True to enable debugging. """
ENABLE_DEBUG = False

""" A mapping of C++ standard exceptions to their CPython equivalents. """
CPP_PY_EXCEPTION_MAPPING = {
    "std::exception": "PyExc_Exception",

    "std::bad_alloc": "PyExc_MemoryError",
    "std::bad_cast": "PyExc_TypeError",
    # "std::bad_exception": "",
    "std::bad_function_call": "PyExc_EnvironmentError", # TODO: Maybe?
    "std::bad_typeid": "PyExc_ValueError",
    "std::bad_weak_ptr": "PyExc_MemoryError",

    "std::logic_error": "PyExc_RuntimeError", # TODO: We should figure out a better error to use
    "std::domain_error": "PyExc_ValueError", # There is no specific domain error
    # "std::future_error": "",
    "std::invalid_argument": "PyExc_ValueError",
    "std::length_error": "PyExc_ValueError",
    "std::out_of_range": "PyExc_IndexError",

    "std::runtime_error": "PyExc_RuntimeError",
    "std::overflow_error": "PyExc_OverflowError",
    "std::range_error": "PyExc_ValueError", # There is no specific range error
    "std::regex_error": "PyExc_ValueError",
    "std::system_error": "PyExc_SystemError",
    "std::underflow_error": "PyExc_UnderflowError"
}

# Use PyDLL instead of CDLL:
#  https://bytes.com/topic/python/answers/701504-fatal-python-error-using-ctypes-python-exceptions
""" A header template to be placed at the beginning of all generated Python files. """
PYTHON_HEADER = """# -*- coding: utf-8 -*-

'''
This file was automatically generated by {0} on {1}.
Do not modify this file unless you know what you are doing.
'''

import ctypes, sys, types, os

__LIBRARY_{2}__ = ctypes.PyDLL(os.path.join(os.path.dirname(os.path.realpath(__file__)),{4},\"{3}\"))
""" # TODO: Include copyright info section

""" A header template to be placed at the beginning of all generated C++ files."""
CPP_HEADER = """/*
 * This file was automatically generated by {0} on {1}.
 *  Do not modify this file unless you know what you are doing.
 *
 */
#include <Python.h>
#include <stdexcept>
#include <exception>
""" # TODO: Include copyright info section

""" A template for generating Python destructor calls. """
PY_DEL_FUNC = """
    def __del__(self):
        if self.cobj and {1}_Destroy:
            {1}_Destroy(self.cobj)
"""

""" A template for loading functions from the library in Python. """
PY_FUNC_LOADER = """{0}try:
{0}    {1} = getattr(__LIBRARY_{2}__, "{1}"){3}
{0}    {1}.argtypes = [{4}]
{0}except AttributeError as e:
{0}    print(str(e), file=sys.stderr)
{0}    {1} = None
"""

""" A template for the C++ destructor wrapper in generated C++ files. """
CPP_DEL_FUNC = """    {0} void {1}_Destroy(void* ptr) {{
        delete ({2}*)ptr;
    }}
"""

""" A template for creating Py Exception objects in generated C++ files if they
    have not already been generated.
"""
CPP_PY_OBJ_WRAPPER_CREATOR = """{0}if({1} == nullptr) {{
{0}    {1} = PyErr_NewException("{2}.{3}", nullptr, nullptr);
{0}    Py_INCREF({1});
{0}    PyModule_AddObject(PyImport_AddModule("__main__"), "{2}", {1});
{0}}}
"""

""" A template for generated python files which attempts to verify the type of a
    variable.
"""
PY_TYPE_CHECK = """{0}if type({1}) != {2}:
{0}    {1} = {3}
"""

""" The current date in ISO format. """
TODAY = datetime.date.today().isoformat()
